use csv;
use open;
use oxychem::get_sdf;
use serde::{Deserialize, Serialize};
use std::error::Error;
use std::fs;
use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command;
use std::{thread, time};

#[macro_use]
extern crate lazy_static;
use tera::{Context as TContext, Tera};

//******************************************************************/
//* NOTE: Use aliases -> names in dwar tables changes
#[derive(Debug, Deserialize, Serialize)]
pub struct DWRecord {
    #[serde(rename(deserialize = "Structure", serialize = "Structure"))]
    pub structure: String,
    #[serde(alias = "Plant", alias = "SMILES", rename(serialize = "SMILES"))]
    //#[serde(alias = "SMILES", rename(serialize = "SMILES"))]
    pub smiles: String,
    #[serde(
        alias = "InChIKey",
        alias = "InChI_Key",
        alias = "InFChIkey",
        alias = "InChI Key",
        rename(serialize = "InChI_Key")
    )]
    pub inchikey: String,
    #[serde(alias = "CAS", alias = "Cas", rename(serialize = "CAS"))]
    pub cas: String,
    #[serde(alias = "Compound", rename = "Compound name")]
    pub compound: String,
}

//******************************************************************/
pub fn open_dwar(path: PathBuf) -> Result<Vec<DWRecord>, Box<dyn Error>> {
    let mut rdr = csv::ReaderBuilder::new()
        .delimiter(b'\t')
        .comment(Some(b'<')) // Ignore datawarrior extra info
        .from_path(path)?;

    let records = rdr
        .deserialize()
        .collect::<Result<Vec<DWRecord>, csv::Error>>()?;

    Ok(records)
}

//******************************************************************/
lazy_static! {
    pub static ref TEMPLATES: Tera = {
        let mut tera = match Tera::new("templates/**/*.tera") {
            Ok(t) => t,
            Err(e) => {
                println!("Parsing error(s): {}", e);
                ::std::process::exit(1);
            }
        };
        tera
    };
}

pub fn create_macro(filepath: PathBuf) -> Result<PathBuf, Box<dyn Error>> {
    // Extract the name of the file without extension
    let file_stem = filepath.file_stem();

    // VIEW parameter from template
    let view_name = PathBuf::from(file_stem.unwrap()).with_extension("sdf");

    // * Using the tera context struct
    let mut context = TContext::new();

    // Insert data
    context.insert("PATH", &filepath);
    context.insert("FILENAME", &filepath.with_extension("txt"));
    context.insert("VIEW", &view_name);

    // * Render
    //let output = TEMPLATES.render("saveSDF.tera", &context)?;
    let mut tera = Tera::default();
    tera.add_raw_template(
        "saveSDF.tera",
        "<macro name=\"saveSDF\">
<task name=\"openFile\">
fileName={{ PATH }}
</task>
<task name=\"saveTextFile\">
fileName={{ FILENAME }}
</task>
<task name=\"closeWindow\">
viewName={{ VIEW }}
saveChanges=no
</task>
</macro>",
    )?;
    let output = tera.render("saveSDF.tera", &context)?;

    // * Save the macro
    let macro_path = &filepath.with_extension("dwam");

    let mut file = File::create(&macro_path)?;
    file.write_all(output.as_bytes())?;

    Ok(macro_path.to_owned())
}

//******************************************************************/
#[cfg(target_os = "macos")]
fn run_macro(macro_path: PathBuf) -> Result<(), Box<dyn Error>> {
    // * Open the macro
    open::with(macro_path, "DataWarrior")?;
    let script = "activate application \"DataWarrior\"
    tell application \"System Events\"
    
        repeat until exists window \"Save Window Content?\" of process \"DataWarrior\"
        end repeat
    
        tell process \"DataWarrior\"
            click button \"No\" of window \"Save Window Content?\"
        end tell
    
    end tell
    return";

    Command::new("osascript")
        .arg("-e")
        .arg(script)
        .output()
        .expect("Close without saving applescript -> command failed to start");

    Ok(())
}

#[cfg(not(target_os = "macos"))]
fn run_macro(macro_path: PathBuf) -> Result<(), Box<dyn Error>> {
    // * Open the macro
    open::with(macro_path, "DataWarrior")?;

    // TODO: Close without saving
    Ok(())
}

#[derive(Debug, Deserialize)]
struct StructureRecord {
    #[serde(rename(deserialize = "Structure [idcode]", serialize = "Structure"))]
    pub structure: String,
}

pub fn get_struct(cid: isize) -> Result<String, Box<dyn Error>> {
    // * Get the sdf
    let sdf_path = Path::new(&cid.to_string()).with_extension("sdf");
    let sdf_data = get_sdf(cid)?;

    let mut file = File::create(&sdf_path)?;
    file.write_all(sdf_data.as_bytes())?;

    // * Generate and run the macro
    let macro_path = create_macro(sdf_path.canonicalize()?)?;
    run_macro(macro_path.clone())?;

    // * Extract structure ID-Code from text file generated by the macro
    let sdf_txt_path = macro_path.clone().with_extension("txt");

    let mut rdr = csv::ReaderBuilder::new()
        .delimiter(b'\t')
        .from_path(sdf_txt_path.clone())?;

    let records = rdr
        .deserialize()
        .collect::<Result<Vec<StructureRecord>, csv::Error>>()?;

    // Clean -> remove generated files
    fs::remove_file(macro_path)?;
    fs::remove_file(sdf_path)?;
    fs::remove_file(sdf_txt_path)?;

    Ok(records[0].structure.clone())
}
